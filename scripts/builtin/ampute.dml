#-------------------------------------------------------------
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
#-------------------------------------------------------------

# Built-in function ampute: Generate missing data for simulation purposes
#
# INPUT PARAMETERS:
# ---------------------------------------------------------------------------------------------
# NAME            TYPE    DEFAULT     MEANING
# ---------------------------------------------------------------------------------------------
# data            Double    ---        A complete data matrix. Values have to be numeric. 
#                                       Categorical variables must have been transformed to dummies.
# prop            Double    ---        A scalar specifying the proportion of missingness by rows (not cells). 
#                                       Can be switched by "byCases" parameter. Should be a value between 0 and 1.
#                                       Default is 0.5.
# patterns        Double    ---        A matrix or data frame of size #patterns by #features, 
#                                       where 0 indicates that a variable should have missing values and 1 indicates that a variable should remain complete.
#                                       Default is generated if necessary.
# freq            Double    ---        A column vector of length #patterns containing the relative frequency 
#                                       with which the patterns should occur.
#                                       Default is generated if necessary.
# mech            String    ---        A string specifying the missingness mechanism, either "MCAR", "MAR" or "MNAR".
#                                       Default is "MAR".
# weights         Double    ---        A matrix or data frame of size #patterns by #variables.
#                                       The matrix contains the weights that will be used to calculate the weighted sum scores.
#                                       Default is generated if necessary.
# std             Boolean   ---        Whether the weighted sum scores should be calculated with standardized data or with non-standardized data.
#                                       Default is TRUE.
# cont            Boolean   ---        Whether the probabilities should be based on a continuous or a discrete distribution.
#                                       Default is TRUE.
# type            String    ---        #TODO STRING VECTOR: A string (or vector of strings NOT YET) containing the type of missingness for each pattern. Either "LEFT", "MID", "TAIL" or '"RIGHT". 
#                                       If a single missingness type is given, all patterns will be created with the same type. 
#                                       (-1="LEFT", 0="MID", 1 = "RIGHT", 2="TAIL"), default="1 => RIGHT"
#                                       If the missingness types should differ between patterns, a vector of missingness types should be given.
#                                       Default is RIGHT.
# odds            Double    ---        A matrix where #patterns defines the number of rows. Each row should contain the odds of being missing for the corresponding pattern.
#                                       Default is generated if necessary.
# bycases         Boolean   ---        If TRUE, the proportion of missingness is defined in terms of cases. If FALSE, the proportion of missingness is defined in terms of cells.
#                                       Default is TRUE.
# run             Boolean   ---        If TRUE, the amputations are implemented. If FALSE, the return object will contain the unamputed input dataset.
#                                       Default is TRUE.
# ---------------------------------------------------------------------------------------------
 
#Output(s)
# ---------------------------------------------------------------------------------------------
# NAME            TYPE    DEFAULT     MEANING
# ---------------------------------------------------------------------------------------------
# amputedData     Double    ---        amputed dataset


m_ampute = function(Matrix[Double] data, Double prop = 0.5, Matrix[Double] patterns = matrix(0, rows=0, cols=0), Matrix[Double] freq = matrix(0, rows=0, cols=0), 
    String mech = "MAR", Matrix[Double] weights = matrix(0, rows=0, cols=0),  Boolean std = TRUE, Boolean cont = TRUE, Matrix[Double] type = matrix(1, rows=0, cols=0),
    Matrix[Double] odds = matrix(0, rows=0, cols=0), Boolean bycases = TRUE, Boolean run = TRUE
  )
  return(Matrix[Double] amputedData)
{
    
    ################
    # SANITY CHECKS
    if (sum(is.na(data) != 0)) {
      stop("Input Error: input data already contains missing values but has to be complete")
    }
    if (ncol(data) < 2) {
        stop("Input Error: data should contain at least two columns")
    }
    if (prop < 0 | prop > 100) {
      stop("Proportion of missingness should be a value between 0 and 1 (for a proportion) or between 1 and 100 (for a percentage)")
    } else if (prop > 1) {
      prop = prop / 100.0
    }
    if (length(patterns) == 0) {
      patterns = ampute_default_patterns(ncol(data))
    } else if ((ncol(patterns) == 1 | nrow(patterns) == 1) & (length(patterns) %% ncol(data) == 0)) {
      numPatternRows = length(patterns) / ncol(data)
      numPatternCols = length(patterns) / numPatternRows
      patterns = matrix(patterns, numPatternRows, numPatternCols)
      if (sum(patterns == matrix(1, rows=numPatternRows, cols=numPatternCols)) == numPatternRows * numPatternCols) {
        stop("All pattern entries containing ones leads to no amputations at all")
      }
    }
    if (ncol(patterns) != ncol(data)) {
      stop("Input Error: number of columns of patterns and data have to be identical")
    }
    if (length(freq) == 0) {
      freq = ampute_default_freq(patterns)
    }
    if ((nrow(freq) != nrow(patterns) & ncol(freq) != 1)) {
      stop("Input Error: the frequency vector has to be of shape (nrow(patterns), 1)")
    }
    if (sum(freq) != 1.0) {
      freq = freq / sum(freq)
      print("Warning: the sum of frequencies should equal 1.0, normalized them by freq/sum(freq) to " + toString(t(freq), sep="|"))
    }
    [newPatterns, newFreq, newProp, rowOneMask, rowZeroMask] = ampute_check_patterns(patterns, freq, prop)
    freq = newFreq
    prop = newProp
    patterns = newPatterns
    if (!bycases) {
      prop = ampute_recalculate_prop(prop, ncol(data), patterns, freq)
    }
    if (mech != "MCAR" & mech != "MAR" & mech != "MNAR") {
      stop("Input Error: mech has to be any of {'MCAR', 'MAR', 'MNAR'}")
    }
    if (mech == "MAR" & sum(rowZeroMask) != 0) {
      stop("Input Error: patterns object contains row of zeros and this kind of pattern is not possible when mechanism is MAR")
    }
    if (mech == "MCAR" & length(weights) != 0) {
      weights = matrix(0, rows=0, cols=0)
      print("Warning: weights are not used for mechanism MCAR")
    }
    if (mech == "MCAR" & length(odds) != 0) {
      odds = matrix(0, rows=0, cols=0)
      print("Warning: Odds matrix is not used when mechanism is MCAR")
    }
    if (mech != "MCAR" & length(weights) != 0) {
      if ((ncol(weights) == 1 | nrow(weights) == 1) & (length(weights) %% ncol(data) == 0)) {
        numWeightsRows = length(weights) / ncol(data)
        numWeightsCols = length(weights) / numPatternRows
        weights = matrix(weights, rows=numWeightsRows, cols=numWeightsCols)
      }
      else if ((ncol(weights) == 1 | nrow(weights) == 1)) {
        stop("Length of weight vector does not match #variables")
      }
    }
    if (length(weights) == 0) {
      weights = ampute_default_weights(patterns, mech)
    }
    if (nrow(weights) != nrow(patterns)) {
      if(nrow(weights) - sum(rowOneMask) == nrow(patterns) & nrow(weights) == nrow(rowOneMask)) {
        slicedWeights = matrix(0, rows=nrow(patterns), cols=ncol(patterns))
        insertIndex = 1
        for (i in 1:nrow(rowOneMask)) {
          if (as.scalar(rowOneMask[i,1]) != 1) {
            slicedWeights[insertIndex, ] = weights[i, ]
            insertIndex = insertIndex + 1
          }
        }
        weights = slicedWeights
      } else {
        stop("Error: there is some dimension missmatch between weights and patterns")
      }
    }
    if (nrow(weights) != nrow(patterns) | ncol(weights) != ncol(patterns)) {
      stop("Input Error: weights input has to be of same dimensions as patterns")
    }
    if (!cont & length(type) > 0) {
      type = matrix(1, rows=0, cols=0)
      print("Warning: type is not used when discrete probabilities (cont == FALSE) are specified")
    }
    if (length(type) == 0) {
      type = ampute_default_type(patterns)
    }
    if (sum(type != -1 & type != 0 & type != 1 & type != 2) > 0) {
      stop("Input Error: type vector contains unspecified entries, only -1, 0, 1, 2 are permitted")
    }
    if (length(type) != nrow(patterns) & length(type) != 1) {
      if (length(type) != nrow(patterns) + sum(rowOneMask)) {
        print("Warning: Type should either have length 1 or length equal #patterns, first element is used for all patterns.")
        type = matrix(type[1,1], rows=nrow(patterns), cols=1)
      } else {
        type = removeEmpty(target=type, margin="rows", select=!rowOneMask)
      }
    }
    if(mech != "MCAR" & length(odds) > 0) {
      if (nrow(odds) != nrow(patterns)) {
        if (nrow(odds) != nrow(patterns) + sum(rowOneMask)) {
          stop("Input Error: number of odds rows doesn't match number of patterns")
        } else {
          odds = removeEmpty(target=odds, margin="rows", select=!rowOneMask)
        }
      }
    }
    if (length(odds) == 0) {
      odds = ampute_default_odds(patterns)
    }
    if (!cont & sum(odds < 0) != 0) {
      stop("Error: odds matrix can only contain positive values")
    }
    if (nrow(odds) != nrow(patterns)) {
      stop("Error: mismatch between number of odds rows and number fo patterns")
    }
    ###################### INPUT CHECKS + DEFAULTS DONE ################################ 
    amputedData = data
    if (run) {
      P = 1 + ampute_prob_sample_replace(sampleValues=seq(1, nrow(patterns), 1), probabilities=freq, sampleSize=nrow(data))
      # CHECK for unique patterns selected
      if (length(P) > 1) {
        patternOccurrenceCounts = t(table(matrix(1, rows=nrow(P), cols=1), P - 1))
        nonOccuringPatterns = patternOccurrenceCounts == 0
        if (sum(nonOccuringPatterns) > 0) {
          unusedPatternIndices = removeEmpty(target=seq(1,length(patternOccurrenceCounts),1), margin="rows", select=nonOccuringPatterns)
          print("Warning: No records are assigned to patterns \n" + toString(t(unusedPatternIndices)) + "These patterns will not be generated. Consider reducing the number of patterns or increasing the dataset size.")
        }
      }
      # calculate replacement matrix R for to be replaced rows by pattern
      # #dataRows x #patterns
      # row i of data will then be amputed according to pattern j if row is candidate for pattern and entry R[i,j] == 0
      if (mech == "MCAR") {
        R = ampute_ampute_mcar(P, patterns, prop)
      } else {
        [scores, candidateMasks] = ampute_sum_scores(P, data, std, weights, patterns)
        if (!cont) {
          R = ampute_ampute_discrete(P, scores, candidateMasks, prop, odds)
        } else {
          R = ampute_ampute_continous(P, scores, candidateMasks, prop, type)
        }
      }
      amputedData = ampute_apply_missing_data(data, patterns, P, R)
    }
    
}
########################################################################################################################
ampute_check_patterns = function(Matrix[Double] patterns, Matrix[Double] freq, Double prop) 
  return(Matrix[Double] patterns, Matrix[Double] freq, Double prop, Matrix[Double] allOnesRowMask, Matrix[Double] allZerosRowMask)
{
  if (sum(patterns != 0 & patterns != 1) > 0) {
    stop("Pattern Error: Argument patterns can only contain 0 or 1 but contains other values")
  }
  allOnesRowMask = rowSums(patterns) == ncol(patterns)
  notAllOnesRowMask = !allOnesRowMask
  propOne = as.scalar(t(freq) %*% allOnesRowMask)
  if (propOne != 0) {
    newProp = (1 - propOne) * prop
    print("Warning: Proportion of missingness has changed from " + prop + " to " + newProp  + " because of pattern(s) with merely ones")
    newFreq = removeEmpty(target=freq, margin="rows", select=notAllOnesRowMask)
    newPatterns = removeEmpty(target=patterns, margin="rows", select=notAllOnesRowMask)
    newFreq = newFreq / sum(newFreq)
    freq = newFreq
    patterns = newPatterns
    prop = newProp
  }
  allZerosRowMask = rowSums(patterns) == 0
}
########################################################################################################################
ampute_default_patterns = function (Integer numDataColumns) 
  return(Matrix[Double] patterns) 
{
  patterns = matrix(1.0, rows=numDataColumns, cols=numDataColumns) - diag(matrix(1.0, rows=numDataColumns, cols=1))
}
########################################################################################################################
ampute_default_freq = function (Matrix[Double] patterns) 
  return(Matrix[Double] freq) 
{ 
  numPatternRows = nrow(patterns)
  freq = matrix(1, rows=numPatternRows, cols=1) / numPatternRows
}
########################################################################################################################
ampute_recalculate_prop = function (Double prop, Integer numDataCols, Matrix[Double] patterns, Matrix[Double] freq) 
  return(Double prop)
{
  miss = prop * numDataCols^2
  sumCases = as.scalar(t(miss * freq) %*% (matrix(1.0, rows=nrow(patterns), cols=1) / rowSums(patterns == 0)))
  if (sumCases > numDataCols) {
    stop("Proportion of missing cells is too large in combination with the desired number of missing variables")
  } else {
    prop = sumCases / numDataCols
  }
}
########################################################################################################################
ampute_default_weights = function (Matrix[Double] patterns, String mech) 
  return(Matrix[Double] weights)
{
  weights = matrix(1, rows=nrow(patterns), cols=ncol(patterns))
  if (mech != "MNAR") {
    weights = weights - (patterns == 0)
  } else {
    weights = weights - (patterns != 0)
  }
}
########################################################################################################################
ampute_default_type = function(Matrix[Double] patterns) 
  return(Matrix[Double] type)
{
  type = matrix(1, rows=nrow(patterns), cols=1)
}
########################################################################################################################
ampute_default_odds = function(Matrix[Double] patterns) 
  return(Matrix[Double] odds)
{
  odds = t(seq(1,4,1) %*% matrix(1, rows=1, cols=nrow(patterns)))
}
########################################################################################################################
ampute_prob_sample_replace = function(Matrix[Double] sampleValues, Matrix[Double] probabilities, Integer sampleSize) 
  return(Matrix[Double] samples)
{
  if(length(sampleValues) != length(probabilities)){
    stop("ERROR: mismatch between length of sampleValues and probabilities")
  }
  if(ncol(sampleValues) != 1 | ncol(probabilities) != 1) {
    stop("ERROR: expecting a column vector for sampleValues and probabilities")
  }
  if(sum(probabilities) != 1) {
    stop("ERROR: sum of probabilities is " + sum(probabilities) + " but has to be 1")
  }

  valueProbMap = cbind(probabilities, sampleValues)
  ordered = order(target=valueProbMap, by=1, decreasing=TRUE, index.return=FALSE)
  ordered[,1] = cumsum(ordered[,1])
  randoms = rand(rows=sampleSize, cols=1, min=0, max=1, pdf="uniform", sparsity=1.0)
  samples = matrix(0, rows=sampleSize, cols=1)
  for (i in 1:nrow(randoms)) {
    break = FALSE
    j = 1
    while (!break & j < nrow(ordered) + 1) {
      if (as.scalar(randoms[i,1]) <= as.scalar(ordered[j,1])) {
        samples[i,1] = ordered[j,2]
        break = TRUE
      }
      j = j + 1 
    }
  }
}
########################################################################################################################
ampute_sum_scores = function(Matrix[Double] P, Matrix[Double] data, Boolean std, Matrix[Double] weights, Matrix[Double] patterns) 
  return(Matrix[Double] scores, Matrix[Double] candidateMasks) 
{
  scores = matrix(0, rows=nrow(data), cols=1)
  candidateMasks = matrix(0, rows=nrow(data), cols=(nrow(patterns)))
  for (i in 1:nrow(patterns)) {
    patternCandidatesMask = P == (i + 1)
    candidateMasks[,i] = patternCandidatesMask
    if (sum(patternCandidatesMask) > 0) {    
      candidates = removeEmpty(target=data, margin="rows", select=patternCandidatesMask)
      if (std) {
        if (sum(patternCandidatesMask) > 1) {
          candidates = scale(X=candidates, center=TRUE, scale=TRUE)
        }
      }
      patternScores = candidates %*% t(weights[i,])
      if (length(patternScores) > 1) {
        patternScores = scale(X=patternScores, center=TRUE, scale=TRUE)
      }
      initIndex = 1
      for (r in 1:nrow(scores)) {
        if (as.scalar(patternCandidatesMask[r, 1]) == 1) {
          scores[r,1] = patternScores[initIndex, 1]
          initIndex = initIndex + 1
        }
      }
    }
  }
  #expecting nrow(P) ones
  #checkMat = matrix(1, rows=nrow(P), cols=nrow(patterns))
  #assert(sum(candidateMasks == checkMat) == nrow(P))
  #expecting one 1 per row in candidateMasks
  #checkVec = matrix(1, rows=nrow(P), cols=1)
  #assert(sum(rowSums(candidateMasks) == checkVec) == nrow(P))
  
}
########################################################################################################################
ampute_ampute_mcar = function(Matrix[Double] P, Matrix[Double] patterns, Double prop) 
  return(Matrix[Double] R) 
{
  R = !(rand(rows=nrow(P), cols=nrow(patterns), min=0, max=1, pdf="uniform", sparsity=1) < prop)
}
########################################################################################################################
ampute_ampute_discrete = function(Matrix[Double] P, Matrix[Double] scores, Matrix[Double] candidateMasks, Double prop, Matrix[Double] odds) 
  return(Matrix[Double] R) 
{
  Rtemp = matrix(0, rows=nrow(P), cols=ncol(candidateMasks))
  for (p in 1:ncol(candidateMasks)){
    if (sum(candidateMasks[,p]) > 0) {
      oddsOfPattern = removeEmpty(target=odds[p,], margin="rows", select=is.na(odds[p,]))
      ng = length(oddsOfPattern)
      scoresOfPattern = removeEmpty(target=scores, margin="rows", select=candidateMasks[,p])
      qPs = seq(0,1,1.0/ng)
      quantiles = quantile(scoresOfPattern, qPs)
      # check for sample too small -> not unique quantiles
      I = rbind(matrix (1,1,1), (quantiles[1:nrow(quantiles)-1,] != quantiles[2:nrow(quantiles),]))
      uniqueQuantiles = removeEmpty (target=quantiles, margin="rows", select = I)
      if (length(uniqueQuantiles) < length(qPs) | sum(is.na(quantiles)) > 0 ) {
        stop("Division of sum scores into quantiles did not succeed. Possibly" +
             " the sum scores contain too few different observations (in case of" +
             " categorical or dummy variables). Try using more variables to" +
             " calculate the sum scores or diminish the number of quantiles in the" +
             " odds matrix")
      }
      # For each candidate the quantile number of a candidate is specified
      for (qIndex in 1:ng) {
        Rtemp[,p] = Rtemp[,p] + (candidateMasks[,p] & (scores >= quantiles[qIndex,]))
      }      
      probVec = t((ng * prop * oddsOfPattern) / sum(oddsOfPattern))
      if (sum(probVec >= 1) > 0) {
        print("Warning: Combination of odds matrix and desired proportion of" +
              " missingness results to small quantile groups, probably" +
              " decreasing the obtained proportion of missingness")
      }
      
      for (qIndex in 1:ng) {
        Rtemp[,p] = replace(target=Rtemp[,p], pattern=qIndex, replacement=as.scalar(probVec[qIndex,1]))
      }
    }
  }
  # zeros will be used for indicating replacement
  Rtemp = replace(target=Rtemp, pattern=0, replacement=NaN)
  randoms = rand(rows=nrow(Rtemp), cols=ncol(Rtemp), min=0, max=1, pdf="uniform", sparsity=1)
  # inversion of <= instead of > because of NaNs
  R = !(randoms <= Rtemp)
}
########################################################################################################################
ampute_ampute_continous = function(Matrix[Double] P, Matrix[Double] scores, Matrix[Double] candidateMasks, Double prop, Matrix[Double] type) 
  return(Matrix[Double] R) 
{
  R = !(rand(rows=nrow(P), cols=ncol(candidateMasks), min=0, max=1, pdf="uniform", sparsity=1.0) < 1)
}
########################################################################################################################
ampute_apply_missing_data = function(Matrix[Double] data, Matrix[Double] patterns, Matrix[Double] P, Matrix[Double] R)
  return(Matrix[Double] amputedData)
{
  nanPatterns = replace(target=patterns, pattern=0, replacement=NaN)
  nanMask = matrix(0, rows=nrow(data), cols=ncol(data))
  for (i in 1:nrow(P)) {
    chosenPattern = as.scalar(P[i,1]) - 1
    if (chosenPattern > 0) {
      if (as.scalar(R[i,chosenPattern]) == 0) {
        nanMask[i,] = nanPatterns[chosenPattern, ]
      }
    }
  }
  amputedData = data + nanMask
}
